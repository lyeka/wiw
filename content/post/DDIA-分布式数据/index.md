---
title: "DDIA 分布式数据"
description: 《设计数据密集型应用》第二章读书笔记
date: 2021-07-03T10:14:53+08:00
image: 
math: 
license: 
hidden: false
comments: true
draft: true
categories:
   - 数据库
tags:
   - 读书笔记
   - 分布式系统
   - DDIA
---
# 分布式数据

为什么需要分布式数据

- 可扩展性：当数据量，读写负载超出了单机的处理能力
- 容错/高可用：当部分机器出现故障时，可以切换到另外机器工作
- 延迟：在用户地域分布广泛时，选择访问其最近的数据中心



当单机处理不了当前的负载需求时，扩展方式可以是：

- 垂直扩展

    - 更换配置更高的机器（CPU, 内存，磁盘等）
    - 选择热插拔组件的机器，如内存条，使用网络通信的磁盘，甚至热插拔CPU

- 水平扩展

    - 由一系列机器（节点）组成一个集群作为整体对外工作，节点之间的协调由软件通过网络控制



垂直扩展的优势在于简单，没有软件协调导致的性能损耗，不存在分布式之间数据不一致，同步冲突等问题，缺点在于成本的上升速率比机器配置上升的速率更高，而且机器也不是可以无限制向上扩展。

相对而言，水平扩展的负载上限更高，廉价机器可以组成一个性价比高的集群，分散的数据除了可以容灾备份外，因地制宜选择就近数据中心可以有效减少请求延迟。但是分布式也有着部署复杂，更新冲突，同步延迟，数据不一致等问题，下面的章节将讲述分布式数据下面临的考验以及解决方案。



数据分布在多个节点有两种常见方式

- 复制（***Replication***）
    - 相同的数据副本存储在不同的节点，每个节点都拥有完备的数据
    - 复制最大的作用的容灾备份，当一部分节点宕机后，可以切换到其它节点工作
    - 复制同样有助于提高数据节点的性能，如在读写分离情况下，将提高系统的负荷能力
- 分区 （**Partitioning**）
    - 将一个完整的数据集拆分成多个子集，存储到不同的节点上
    - 数据系统/业务代码会根据请求分析其所需的数据在哪些节点上，从而正确的从不同的节点上获取组合数据



复制和分区两种形式不是对立，它们可以单独或者组合一起工作，如各个子数据集同样可以以复制的形式冗余在不同节点上。



## 复制



数据集总不是一成不变的，绝大部分都处于变更中，复制同步就成了首先要面对的问题。流行的三种变更复制算法如下：

- 单领导者
- 多领导者
- 无领导者



领导者（leader)是指在多副本中负责接受客户端的写入请求的副本，再写入数据到本地的同时，将变更的数据同步到其它追随者 (follower）副本上。

领导者可以接受客户端的读写数据操作，追随者只能接受读操作





### 单领导者

最常见的复制模式是一个领导者加一个或者多个追随者，这种模型也成为主从结构。许多数据库都内置了这种模型的支持，如MySQL，PostgreSQL，MongoDB等。



#### 同步复制与异步复制

当主库接收到写操作时，在写入到本地存储后，主库还会向从库转发数据更新操作。如果需要从库接收到数据更新操作并且从库成功更新数据后主库才向客户端相应成功写入，这种复制称为同步复制；如果只是转发了数据更新请求，但不需要等到从库确认写入主库就直接响应客户端，这种模式称为异步复制。

全部复制模式选择同步通常是不太实际的，因为单个节点失效的话就会导致整个系统不可用。所以大部分主从架构都是选择半同步——即同步复制与异步复制混用，主库只需要收到部分副本的的成功写入操作即可向客户端响应；或者选择全异步复制，这样会能更快响应客户端，但数据丢失的风险也会相应提高。



#### 故障转移（failover）

当主库宕机时，需要提升某个从库作为主库，客户端需要重新配置主库地址，从库需要切换领导者，这个过程称为故障转移。

故障转移可以人为解决，但很多情况下，我们希望得到自动故障转移的支持，即集群可以自动更新配置完成上诉操作。



自动故障转移通常包括下面步骤：

1. 确认主库失效
    - 如何判断主库失效是个难题，可能主库与从库只是短时间内网络阻塞了
    - 通常大多数系统只是简单的使用超时来判断主库的失效——节点之间会定时地传递消息（心跳），如果某个节点在一段时间内没有响应，则可以认为该节点失效
2. 选举出主库
    - 当失效的节点是主库时，这时需要剩余的副本阶段选举
3. 重新配置
   - 客户端更新写请求的endpoin指向新主库
   - 旧主库恢复时认可新主库，降级为从库

#### 复制日志实现

##### 基于语句的复制

记录写请求的语句（如MySQL中的Insert、Update、Delete等SQL)，将其转发给从库执行

存在的问题

- 存在非确定性值，如调用时间函数，
- 执行顺序需求，如语句依赖现有数据

MySQL5.1之前只支持基于语句的复制



##### WAL

预写式日志（Write-ahead logging， WAL)指在实际修改数据时先写入log文件，以支持事务中的回滚，MVCC等操作。日志文件包含了所有的数据库写入的仅追加字节数组，所以可以通过传输日志文件来构建一个相同的副本。

存在的问题

- 由于传输的是底层数据（字节数组），所以在存储方式发生了变化的不同数据库版本之间复制可能会出现不兼容问题

PostgreSQL、Oracle采用这种方式实现复制。



##### 基于行的复制

基于行的复制会以逻辑日志的形式传输以复制，逻辑日志通常以行为粒度，记录写请求前后受影响的行的前后状态，从库会将受影响的行变更为后者状态。这种方式也利于外部系统通过消费逻辑日志来捕捉数据库的变更。

MySQ支持基于行的复制，还支持基于语句混合基于行的复制。



##### 基于触发器的复制

当数据变更触发复制前时想要做一些额外的数据处理，处理借助外部的应用程序外，还可以借助触发器，存储过程来实现对应操作。如但数据变更时，将数据复制到另外一张表，外部程序读取该表以同步复制到其它库

#### 复制延迟

TODO

















