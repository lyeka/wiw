---
title: "Go GC"
description: 从Go的实现看GC
date: 2021-07-02T15:13:44+08:00
image: index.jpg
math: 
license: 
hidden: false
comments: true
categories:
  - program
  - go
tags:
  - gc
---
# GC

我们知道，变量会被分配到栈和堆上，而栈上分配的对象在使用完毕出栈之后会被操作系统自动回收，但是堆上的变量则不被操作系统管理，这就需要程序自己实现堆上变量的回收，否则在程序的生命周期内，进程占用的内存会一直上升，不再需要的对象一直占据内存空间，也就是发生了所谓的内存泄露。

关于堆上对象的回收，编程语言分成了两种，一种是需要开发者手动指定内存的释放，如C/C++等，当我们认为这个对象不再需要用到的时候，需要手动调用`free`等来释放掉对象所在的内存；另外一种是具备自动垃圾回收的 ，开发者无需关注一个对象的内存释放，程序语言会自动分析堆上的对象，将不再需要的对象回收，释放对应的内存。

## 垃圾回收算法

GC的实现大致可以分为两类

### 引用计数

最早也是最简单的垃圾回收实现算法。每个对象会附件一个计算器，但其被其他对象引用时计算器加一，否则减一。当计数器被置零时，所属的对象就会被回收掉。Python (Cpython)、Objective-C、PHP等采用了引用计数作为GC算法。

优点：

1.  即使在内存濒临限制的情况下性能也不会下降得很严重

缺点：

1. 无法回收处理循环引用的对象（除非使用Recycler 算法)
2.  频繁更新引用计数器会降低运行效率，尤其在多线程环境下



### 追踪式

追踪垃圾回收算法通过定期从“根”对象出发扫描，分析对象之间得引用关系，最终将没有其他对象引用的对象视为垃圾回收掉释放内存空间。Go、Java、Python(Pypy)等采用了追踪式垃圾回收作为GC实现。



追踪式垃圾回收有多种实现，许多语言的GC实现并不是单一实现某种，而是多种结合：

- 标记 - 清除

    - 扫描对象，标记不再需要的对象，清除垃圾

- 标记 - 整理

    - 与标记清除类似，不过在回收的同时会将存留的对象整理搬运到连续的内存空间，以减少内存碎片
    - Java大部分GC实现在分代回收的基础上结合了标记-整理

- 分代：

    - 将对象按存活时间划分为新生代/老生代（/永生代），对于不同代的有着不同的回收频率，存活时间越老的代回收频率越低
    - 每次回收，会将对象附加的计数器加一来界定年龄代
    - Node.js(V8) 、 Java(CMS)、Java(G1)、.NET实现了分代式垃圾回收

- 增量回收：

    - 将内存划分为若干区，每次只对其中一个分区做回收，从而避免暂停所有线程

    - Node.js(v8 *Orinoco*) 在分代垃圾回收的基础上实现了增量回收



基本上追踪式的垃圾回收都是以**标记-清除**为基础的，在此基础上添加一些特性优化，但本质都是减少垃圾回收过程中暂停业务线程（STW) 时间。



## Go GC 实现原理

Go实现的是追踪式的标记-清除垃圾回收机制



这里首先引入两个名称

- 赋值器（Mutator）：用户态代码，即开发者编写的代码，其中包括了创建对象，修改对象（之间的引用关系）等等行为
- 回收器（Collector）：执行垃圾回收的组件



### 三色标记法

垃圾回收的首要的一步便是标记，Go语言中采用的是三色标记法 ，通过**可达性分析**将对象按颜色划分成三种类型

- 白色对象：回收器没有访问到的对象（不可达），在垃圾回收最后的清除阶段中会被回收
- 灰色对象：回收器已经访问到的对象，还是还没有遍历完其子节点（即该灰色对象还有引用的对象回收器没有访问到），是一种中间状态，回收器会一直执行标记工作直到最后只剩下白色与黑色对象
- 黑色对象：回收器已经访问到且其所有子节点均被访问器访问过的的对象，在垃圾回收清除阶段中将被保留

TODO 补充强弱三色模型



#### 着色过程

在垃圾回收的标记工作开始启动后，首先回收器会从根（root)对象集合（包括了寄存器、栈、全局变量）出发，遍历所有的堆上对象：

1. 刚开始所有的对象都是白色，将根集合中的对象置灰，加入灰色对象列表
2. 从灰色列表取出一个灰色对象，将其置黑，因为下面的步骤将会遍历标记其子对象
3. 遍历2步骤中的灰色对象的子对象，将访问到的子对象置灰，放入灰色对象列表
4. 循环执行2，直到灰色对象列表为空，现在堆上就只剩下白色和黑色对象了



### 内存屏障

**为什么需要内存屏障**

在暂停业务逻辑，赋值器停止工作（STW）下进行垃圾回收，垃圾回收完毕后再恢复业务逻辑这种GC实现下，是不需要内存屏障的，但是为了减少STW的时间，往往会采取GC与业务逻辑**并发执行**，这就可能导致对象关系在GC扫描后发生变化，如一个白色对象W1重新被黑色对象B1引用，这时如果回收了W1，就有可能导致业务逻辑出错。

这时候就需要引入内存屏障，内存屏障类似一个hook函数，在编译期间加入，当进程对内存进行修改的时候会执行这个hook函数，GC利用这个hook来保证回收的正确性。而且内存屏障保证了按其声明的顺序执行，这意味着其不会被编译时被优化调整，也不会被CPU乱序执行。

在三色模型抽象下，内存屏障的作用是当赋值器修改对象之间的关系前，内存屏障会hook住这个写操作，对对象进行着色，防止不该回收的对象被回收当作白色垃圾清洗掉。

如何着色衍生出了不同的屏障类型。Go语言中首先引入了**插入（Dijkstra）写屏障**，后面借鉴删除（Yuasa）屏障思想实现了**混合写屏障**。



#### 插入写屏障

Go在1.5版本的时候加入了插入写屏障（也称Dijkstra屏障），其思想是如果黑色对象引用了白色对象的话，将白色

对象染灰（可达），这就实现了强一致三色模型，回收器标记与赋值器得以并发。

但是由于每次指针赋值前执行都会执行写屏障，这会带来一定的性能损耗（需要注意的是，非GC标记阶段，屏障开关是关闭的，不会执行屏障操作，这里指的是GC标记阶段开始了写屏障的条件下的损耗），所以Go选择了关于栈上的写操作不引入屏障。为了规避栈上对象引用白色对象，而回收器清除了被栈上对象引用了的白色对象这种情况，在GC的标记终止阶段需要堆栈进行重扫，这个重扫阶段是STW的。

插入写屏障公式如下

```go
func DijkstraWritePointer(slot, ptr) {
    shade(ptr)
    *slot = ptr
}
```





#### 删除屏障

删除屏障的思想是当对象A删除对对象B的引用导致其不可达时，将对象A染灰。这其实是实现了弱三色模型——即允许黑色对象指向白色对象，但是灰色到白色对象这一路径没被打破的话，还是不会出现对象丢失的情况，因为被染灰的对象会被重新扫描。

删除屏障由于会重新染灰黑色对象的情景，所有会导致某些对象被多次扫描。

删除屏障公式如下

```go
func YuasaWritePointer(slot, ptr) {
    shade(*slot)
    *slot = ptr
}
```



#### 混合写屏障

Go在1.8版本实现了混合写屏障，其基本思想是对于被覆盖的对象染灰，且如果当前栈没有被扫描的话，将新对象也染灰。

混合屏障避免全局STW扫描栈：

- 不完全的插入写屏障需要在标记末尾扫栈
- 删除写屏障需要开始阶段扫栈

而是在标记阶段单独挂起某个goroutine栈，将其染黑，从而避免了删除屏障中的波面回退，因为栈被染黑后，其赋值器为黑色复制器（分配的对象染黑且需要再扫描），从而实现真正的并发标记。

TODO 补充黑/灰赋值器

混合写屏障公式如下

```go
writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```



### 清除



### 归还内存



### Go GC 演化

TODO 添加图示

- 单线程GC

    - Go GC 最初的版本会将业务代码停止掉，**单线程串行**执行标记、清除工作
- 并发GC
    - 加入并行策略，多线程STW**并行**执行标记工作（赋值器挂起），多线程且与业务代码**并发**执行清除工作
    - STW时间仍然较长
- 加入写屏障（Go1.5)
    - 加入写屏障后，标记工作与业务代码**并发**执行
    - STW时间大幅度下降
- 栈收缩
    - 在GC标记阶段减少栈的使用空间以减少STW时间
- 加入混合写屏障
    - 加了混合写屏障后，减少了标记中止阶段重新扫描栈的成本
    - 消除了全局STW（还是存在局部的赋值挂起）



### Go GC 代码实现

TODO









ref

- [垃圾回收 (计算机科学)](https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95)
- [引用计数](https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0)
- [追踪垃圾回收](https://zh.wikipedia.org/wiki/%E8%BF%BD%E8%B8%AA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)
- [V8 的并发标记](https://v8.js.cn/blog/concurrent-marking/)
- [垃圾回收的基本想法](https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/basic/)
- [垃圾收集器](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/)
- [Java中9种常见的CMS GC问题分析与解决](https://tech.meituan.com/2020/11/12/java-9-cms-gc.html)
- [Recycler算法——环状引用计数算法的一种实现](https://www.jianshu.com/p/4d59698030f1)
- [Golang 混合写屏障原理深入剖析，这篇文章给你梳理的明明白白！！！](https://blog.csdn.net/CSDN_bang/article/details/107572440)

